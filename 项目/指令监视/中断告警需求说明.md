## 背景

你是一名java开发工程师，现在你可以获取到卫星的计划入圈时间与出圈时间，现在有很多卫星的很多计划，同时，在卫星入圈之后会发送遥测数据，我在我已经在缓存中利用一个activeMap获取每个卫星最新的遥测获取时间。

## 需求

我需要实现需求

1、实现对于实际卫星迟到入圈和提前出圈的告警，如果超过设置的阈值，那么发送告警，并将迟到和提前时间进行保存。

2、如果卫星入圈之后没超过3秒中没有发中断，则2秒钟发一次告警，并且记录每次中断总的中断时间

## 技术栈

SpringBoot2.7.4

redis

kafka

elk

mysql

注意我使用的技术栈是上述，在此次开发中合理分析，不一定要用上述技术栈，但是要使用mysql存储告警信息



## 设计

### **核心思想**

每个卫星的计划生命周期可抽象为一个“有限状态机（FSM）”

```
┌────────────┐       ┌────────────┐
│  WAIT_ENTER │────→│  IN_CIRCLE  │────→│  EXITED  │
└────────────┘       └────────────┘      └───────────┘
         ↑
         └──────←───────┐
                         │
          （迟到入圈）   │（提前出圈）
                         │
          ┌────────────┐ │
          │INTERRUPTED │─┘
          └────────────┘
```

### 一、状态机设计概览

| 状态名称      | 含义       | 可能的事件                                            | 转移结果      |
| ------------- | ---------- | ----------------------------------------------------- | ------------- |
| `WAIT_ENTER`  | 等待入圈   | 收到遥测数据                                          | → `IN_CIRCLE` |
| `IN_CIRCLE`   | 卫星已入圈 | ① 超时未发数据 → `INTERRUPTED`；② 计划出圈 → `EXITED` |               |
| `INTERRUPTED` | 遥测中断中 | 收到数据 → `IN_CIRCLE`                                |               |
| `EXITED`      | 卫星出圈   | 结束计划                                              |               |

### 二、状态枚举

```
public enum SatelliteState {
    WAIT_ENTER,
    IN_CIRCLE,
    INTERRUPTED,
    EXITED
}
```

### 三、状态机上下文（每颗卫星）

```
@Data
@AllArgsConstructor
@NoArgsConstructor
public class SatelliteContext {
    private String satelliteId;
    private String planId;
    private SatelliteState state = SatelliteState.WAIT_ENTER;
    private Date lastTelemetry;
    private Date interruptStart;
}
```

### 四、状态事件定义

```
public enum SatelliteEvent {
    TELEMETRY_RECEIVED,   // 收到遥测
    NO_DATA_TIMEOUT,      // 超时无数据
    PLAN_EXIT_TIME_REACHED // 到达计划出圈时间
}
```

### 五、状态机实现核心（面向对象封装）

我们采用 **状态模式（State Pattern）**：

每个状态实现一个接口：

```
public interface SatelliteStateHandler {
    void handle(SatelliteContext ctx, SatelliteEvent event, Date now);
}
```

###  1. 等待入圈状态（WAIT_ENTER）

```
@Component
public class WaitEnterState implements SatelliteStateHandler {
    @Autowired
    private AlarmService alarmService;

    @Override
    public void handle(SatelliteContext ctx, SatelliteEvent event, Date now) {
        if (event == SatelliteEvent.TELEMETRY_RECEIVED) {
            Date planEnter = planService.getPlanEnterTime(ctx.getPlanId());
            long delay = (ctx.getLastTelemetry().getTime() - planEnter.getTime()) / 1000;

            if (delay > THRESHOLD_LATE) {
                String desc = String.format("卫星实际入圈时间：%s，计划入圈时间：%s，延迟：%d 秒",
                        fmt(ctx.getLastTelemetry()), fmt(planEnter), delay);
                alarmService.createAlarm(ctx.getSatelliteId(), ctx.getPlanId(),
                        "LATE_ENTRY", delay, 0, desc);
            }
            ctx.setState(SatelliteState.IN_CIRCLE);
        }
    }
}
```

------

### 2. 已入圈状态（IN_CIRCLE）

```
@Component
public class InCircleState implements SatelliteStateHandler {
    @Autowired
    private AlarmService alarmService;

    @Override
    public void handle(SatelliteContext ctx, SatelliteEvent event, Date now) {
        if (event == SatelliteEvent.NO_DATA_TIMEOUT) {
            ctx.setInterruptStart(ctx.getLastTelemetry());
            ctx.setState(SatelliteState.INTERRUPTED);
        } else if (event == SatelliteEvent.PLAN_EXIT_TIME_REACHED) {
            Date planExit = planService.getPlanExitTime(ctx.getPlanId());
            long early = (planExit.getTime() - ctx.getLastTelemetry().getTime()) / 1000;
            if (early > THRESHOLD_EARLY) {
                String desc = String.format("卫星实际出圈时间：%s，计划出圈时间：%s，提前：%d 秒",
                        fmt(ctx.getLastTelemetry()), fmt(planExit), early);
                alarmService.createAlarm(ctx.getSatelliteId(), ctx.getPlanId(),
                        "EARLY_EXIT", early, 0, desc);
            }
            ctx.setState(SatelliteState.EXITED);
        }
    }
}
```

------

###  3. 中断状态（INTERRUPTED）

```
@Component
public class InterruptedState implements SatelliteStateHandler {
    @Autowired
    private AlarmService alarmService;

    @Override
    public void handle(SatelliteContext ctx, SatelliteEvent event, Date now) {
        if (event == SatelliteEvent.TELEMETRY_RECEIVED) {
            long duration = (now.getTime() - ctx.getInterruptStart().getTime()) / 1000;
            String desc = String.format("中断开始时间：%s，中断恢复时间：%s，总中断时长：%d 秒",
                    fmt(ctx.getInterruptStart()), fmt(now), duration);
            alarmService.createAlarm(ctx.getSatelliteId(), ctx.getPlanId(),
                    "INTERRUPTION", 0, duration, desc);

            ctx.setInterruptStart(null);
            ctx.setState(SatelliteState.IN_CIRCLE);
        }
    }
}
```

------

### 4. 出圈状态（EXITED）

```
@Component
public class ExitedState implements SatelliteStateHandler {
    @Override
    public void handle(SatelliteContext ctx, SatelliteEvent event, Date now) {
        // 出圈后不再处理事件
    }
}
```

------

### 六、状态机调度器（中央调度器）

定时任务只负责产生事件，不再直接做逻辑判断。

```
@Component
public class SatelliteStateMachineScheduler {

    @Autowired
    private Map<SatelliteState, SatelliteStateHandler> stateHandlers;
    @Autowired
    private RedisTemplate<String, Date> redisTemplate;
    @Autowired
    private PlanService planService;

    private final Map<String, SatelliteContext> contextMap = new ConcurrentHashMap<>();

    @Scheduled(fixedRate = 2000)
    public void runStateMachine() {
        Date now = new Date();
        List<SatellitePlan> plans = planService.getCurrentPlans();

        for (SatellitePlan plan : plans) {
            String satId = plan.getSatelliteId();
            SatelliteContext ctx = contextMap.computeIfAbsent(satId, id -> new SatelliteContext(id, plan.getPlanId(), SatelliteState.WAIT_ENTER, null, null));

            Date lastTelemetry = redisTemplate.opsForValue().get("activeMap:" + satId);
            ctx.setLastTelemetry(lastTelemetry);

            SatelliteEvent event = detectEvent(ctx, plan, now);
            stateHandlers.get(ctx.getState()).handle(ctx, event, now);
        }
    }

    private SatelliteEvent detectEvent(SatelliteContext ctx, SatellitePlan plan, Date now) {
        if (ctx.getState() == SatelliteState.WAIT_ENTER && ctx.getLastTelemetry() != null)
            return SatelliteEvent.TELEMETRY_RECEIVED;

        if (ctx.getState() == SatelliteState.IN_CIRCLE) {
            if (now.after(plan.getPlanExitTime())) return SatelliteEvent.PLAN_EXIT_TIME_REACHED;
            if (ctx.getLastTelemetry() != null && (now.getTime() - ctx.getLastTelemetry().getTime()) > 3000)
                return SatelliteEvent.NO_DATA_TIMEOUT;
        }

        if (ctx.getState() == SatelliteState.INTERRUPTED && ctx.getLastTelemetry() != null &&
                (now.getTime() - ctx.getLastTelemetry().getTime()) <= 3000)
            return SatelliteEvent.TELEMETRY_RECEIVED;

        return null;
    }

    private String fmt(Date date) {
        return new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(date);
    }
}
```

------

### 告警保存逻辑（每次中断都写一次）

```
@Service
public class AlarmService {

    @Autowired
    private AlarmRepository alarmRepository;
    @Autowired
    private KafkaTemplate<String, String> kafkaTemplate;

    public void createAlarm(String satId, String planId, String type, double delay, double interruptDuration, String desc) {
        SatelliteAlarm alarm = new SatelliteAlarm();
        alarm.setSatelliteId(satId);
        alarm.setPlanId(planId);
        alarm.setAlarmType(type);
        alarm.setDelayTime(delay);
        alarm.setInterruptDuration(interruptDuration);
        alarm.setAlarmTime(new Date());
        alarm.setDescription(desc);
        alarm.setStatus("NEW");

        alarmRepository.save(alarm);
        kafkaTemplate.send("satellite_alarm_topic", JSON.toJSONString(alarm));

        log.warn("[{}][{}] {}", satId, type, desc);
    }
}
```

### 七、最终效果

| 功能             | 状态机版效果                       |
| ---------------- | ---------------------------------- |
| 遥测中断多次告警 | ✅ 每次恢复自动触发中断告警         |
| 延迟与提前告警   | ✅ 状态转移自动触发                 |
| 告警描述含时间   | ✅ 各状态类自行生成描述             |
| 中断时长独立字段 | ✅ AlarmService 参数独立传入        |
| 逻辑清晰可扩展   | ✅ 新增状态（如“通信异常”）非常方便 |