## Mysql的并发控制方式有哪些？

锁与MVCC

锁分为共享锁（S锁）和排他锁（X锁），又根据锁的粒度不同分为表锁和行锁。

MVCC机制是乐观锁机制，本质上是隐藏字段+ReadView+undo log实现的一种机制。

读已提交与重复读隔离基本是基于MVCC机制实现的

串行读是基于锁机制实现的。

mysql的默认隔离级别是可重复读。



## Mysql锁

**表锁**：针对非索引字段加的锁

**行锁**：针对索引字段加的锁

当我们执行 DELETE、UPDATE语句时，如果WHERE条件字段没有命中唯一索引或者索引失效的话，就会导致扫描全表对表中所有记录进行加锁。

### 行锁

行锁分类：

- 记录锁：单行的锁
- 间隙锁：一个范围的锁，不包括本身
- 临键锁（Next-Key Lock）：记录锁+间隙锁，锁住范围，包括本身

在默认隔离级别下行锁所用的是Next-Key Lock

由于 MVCC 的存在，对于一般的 `SELECT` 语句，InnoDB 不会加任何锁。不过， 你可以通过以下语句显式加共享锁或排他锁。

```
# 共享锁 可以在 MySQL 5.7 和 MySQL 8.0 中使用
SELECT ... LOCK IN SHARE MODE;
# 共享锁 可以在 MySQL 8.0 中使用
SELECT ... FOR SHARE;
# 排他锁
SELECT ... FOR UPDATE;
```

### 表锁

加表锁的情况

- ALTER TABLE：修改表结构，如添加或删除列，修改列类型等。
- DROP TABLE：删除表。
- RENAME TABLE：重命名表。
- TRUNCATE TABLE：清空表中的所有数据。
- 备份与恢复
- 手动加锁
- Delete、Update的WHERE条件字段没有命中唯一索引或者索引失效的话，就会导致扫描全表对表中所有记录进行加锁。

加表锁得判断一下是不是有行锁，不能一行一行找，因此有了意向锁

**意向共享锁（Intention Shared Lock，IS 锁）**：事务有意向对表中的某些记录加共享锁（S 锁），加共享锁前必须先取得该表的 IS 锁。

**意向排他锁（Intention Exclusive Lock，IX 锁）**：事务有意向对表中的某些记录加排他锁（X 锁），加排他锁之前必须先取得该表的 IX 锁。

**意向锁是由数据引擎自己维护的，用户无法手动操作意向锁，在为数据行加共享/排他锁之前，InooDB 会先获取该数据行所在在数据表的对应意向锁。**

在使用行锁或者表锁的时候先加一个意向锁来标识一下。
