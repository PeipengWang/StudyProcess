# 高性能Mysql

## 小技巧

### 三种方法查看单挑查询性能

1、show profiles；
show profile
可以直接通过表格形式查出语句执行的时间
2、show status
3、select event_name,count_star,sum_time_wait from events_waits_summary_global_by_event_name ;

### 使用慢查询日志

设置全局变量long_query_time=0
或者
使用tcpdump和pt-query-digest工具

### explain参数

id：查询的标识符，同一查询中，id值相同表示执行的是同一个查询；
select_type：查询的类型，常见的有SIMPLE（简单查询）、PRIMARY（主查询）等；
table：查询涉及到的表，如果是子查询或者联合查询，会显示为derived或者union；
partitions：分区数，如果表没有分区，此列为NULL；
type：查询的方式，常见的有ALL（全表扫描）、index（索引查询）等；
possible_keys：查询涉及到的索引，多个索引用逗号分隔；
key：实际使用的索引；
key_len：索引中使用的字节数；
ref：表示哪个字段或常数与key一起被使用；
rows：MySQL认为它执行查询时必须检查的行数；
filtered：通过where条件过滤后剩余的行数，取值范围0~1；
Extra：包含MySQL解决查询的详细信息，比如是否使用了临时表、是否使用了文件排序等。
在执行查询时，MySQL会根据查询的条件和表的结构计算出一个查询执行计划，该执行计划就是上述的各列，可以通过explain命令来查看执行计划，帮助优化查询性能。

## 数据类型优化

1、数据范围越小越好
能使用整形就不用字符串型，字符串型满足条件的情况下范围越小越好
2、简单就好
3、尽量避免使用NULL
能定义为not null 就尽量避免使用NULL，除非有null的要求。

整数类型：
unsigned 是非负数的意思，能使得性能提升一倍
对于小数类型的数据，建议使用DECIMAL类型而不是FLOAT或DOUBLE类型。DECIMAL类型存储的精度更高，而FLOAT和DOUBLE类型可能在精度上有损失。
在设计表结构时，尽量避免使用BLOB和TEXT类型，因为它们会占用更多的磁盘空间和内存空间，执行速度也较慢。
对于VARCHAR类型，尽量使用固定长度的VARCHAR，例如VARCHAR(10)，而不是可变长度的VARCHAR，例如VARCHAR(255)。这样可以减少存储空间，提高查询效率。
避免使用ENUM类型，因为它在存储和查询时效率较低，不利于扩展和维护。
时间类型的TIMESTAMP效率比DATETIME的空间效率更高。
谨慎使用BIT类型，这个类型实际存储为字符串类型。
如果需要保存很多true/false，那么可以考虑使用set类型，能比较有效的利用存储空间。但是它的扩展性差点，改变的时候需要alter table。
**主键或者外键的选择**
整数型设置为AUTO_INCREMENT
UUID值，但需要用UNHEX()函数转换UUID为16位数字。

## 索引的优化

原则：
设计一个高效的索引需要考虑以下几个方面：
选择合适的索引类型：Mysql支持多种类型的索引，包括B-tree索引、Hash索引、Full-text索引等，不同的索引类型适用于不同的场景，需要根据具体的需求进行选择。
索引列的选择：应该选择那些在查询条件、排序条件和连接条件中经常用到的列作为索引列，避免选择无用的列作为索引列，这样可以提高索引的效率。
索引列的顺序：在选择索引列时，应该优先选择区分度高的列，即不同值较多的列作为索引列，并将这些列放在索引的前面，这样可以减少扫描的数据量，提高查询效率。
索引长度的选择：索引长度的选择应该根据列的类型和列的取值范围来确定，索引列的长度过长会导致索引文件过大，索引列的长度过短会导致索引失效。
避免过多的索引：过多的索引会导致索引文件过大，占用磁盘空间，同时也会降低查询的效率，因此应该避免创建过多的索引，只选择那些真正有用的索引。
定期优化索引：定期对索引进行优化，包括检查索引的使用情况、删除无用的索引、调整索引的顺序和长度等，可以提高数据库的性能。

## 查询性能优化

## 优化器对于关联查询的处理与优化

下面是大致的内部处理过程：
解析 SQL 语句：MySQL首先需要解析查询语句并生成执行计划。在这个阶段，MySQL 将检查查询中使用的表和列是否存在，并且会根据 WHERE 子句和 JOIN 条件来确定哪些索引可以使用，以及执行联接的顺序等信息。
优化执行计划：MySQL 接下来会对执行计划进行优化，目的是生成最优的执行计划。这个阶段包括以下步骤：
a. 估算查询成本：MySQL 会估算每个可能的执行计划的成本，并选择最优的执行计划。成本估算的主要依据包括查询的数据量、磁盘 I/O 操作和 CPU 负载等。
b. 选择最优的执行计划：MySQL 会比较所有可能的执行计划的成本，并选择最优的执行计划。
c. 生成执行计划：MySQL 会根据最优的执行计划，生成用于执行查询的代码。
执行联接查询：MySQL 接下来会执行联接查询，具体步骤如下：
a. 打开第一个表：MySQL 打开查询中的第一个表，并读取其中的数据。
b. 执行联接查询：MySQL 对于第一个表中的每一行，会在第二个表中查找匹配的行，并将两个表中匹配的行组合成一行。
c. 筛选结果：MySQL 根据 WHERE 子句中指定的条件对结果进行筛选。
d. 排序结果：如果有 ORDER BY 子句，则 MySQL 会对结果进行排序。
e. 分页结果：如果有 LIMIT 和 OFFSET 子句，则 MySQL 会对结果进行分页。
f. 返回结果集：最后，MySQL 将结果集返回给客户端。

如果关联查询中涉及到了很多表，那么查询优化器会尝试生成不同的执行计划，并对每个执行计划的执行代价进行评估，然后选择代价最小的执行计划。关联查询优化器在生成执行计划时，会根据查询的具体情况和数据库的统计信息等，进行综合考虑，选择最优的执行计划。

当涉及到大量的表时，查询优化器通常会采用一些特殊的算法来生成执行计划，以减少执行代价和查询时间。其中，一种常用的算法是基于动态规划的算法，该算法可以通过多次扫描表，计算出最优的执行计划，并将其缓存起来以便重复使用。
或者表关联太多就会使用贪婪算法。

此外，查询优化器还可以利用一些特殊的技术来优化查询性能，例如将关联查询中的子查询转化为连接查询，利用索引和缓存来提高查询效率等等。总之，查询优化器在处理大量表的关联查询时，会根据具体情况进行优化，并尽可能选择最优的执行计划，以提高查询性能。

## 排序优化

MySQL内部的排序优化主要有以下几种方式：
利用索引：如果查询的字段已经被索引了，MySQL可以使用索引来避免排序。当排序所需的数据可以直接从索引中获取时，MySQL会使用覆盖索引来避免排序，从而提高排序性能。
利用缓存：如果排序的结果集很小，MySQL可以将排序结果缓存到内存中，以避免重复排序。
利用快速排序算法：MySQL内部使用快速排序算法来对数据进行排序，该算法的时间复杂度为O(nlogn)，能够在较短时间内完成排序操作。
利用归并排序算法：如果排序的数据量较大，MySQL会使用归并排序算法来对数据进行排序，该算法的时间复杂度为O(nlogn)，能够在较短时间内完成排序操作。此外，MySQL还使用了一种称为“临时文件”的技术，将排序数据存储到磁盘上，以避免内存不足导致的排序失败。
利用多个排序算法：MySQL还可以结合多个排序算法来提高排序性能。例如，在数据量较小的情况下，可以使用插入排序或冒泡排序等算法，以避免快速排序或归并排序带来的额外开销。

总之，MySQL内部的排序优化主要包括利用索引、缓存、快速排序算法、归并排序算法以及多个排序算法的组合，以提高排序性能和效率。

## 查询优化器的局限性

### 关联子查询

最坏的是where查询条件中包含IN()的子查询，因为他会先查询外层进行全表扫描，然后根据查出来的数据挨个进行子查询，这对于效率影响太大
可以优化的地方：
1、使用JOIN代替IN：如果IN子句中的值是另一张表中的数据，可以使用JOIN代替IN。例如，将"SELECT * FROM t1 WHERE col1 IN (SELECT col2 FROM t2)"改为"SELECT t1.* FROM t1 INNER JOIN t2 ON t1.col1 = t2.col2"。
2、使用EXISTS代替IN：使用EXISTS代替IN可以提高查询性能。例如，将"SELECT * FROM t1 WHERE col1 IN (SELECT col2 FROM t2)"改为"SELECT * FROM t1 WHERE EXISTS (SELECT 1 FROM t2 WHERE t1.col1 = t2.col2)"。
3、将IN子句中的值放入一个临时表中：将IN子句中的值放入一个临时表中，然后使用INNER JOIN或LEFT JOIN与主查询表进行连接，可以提高查询性能。
4、使用LIMIT优化查询：如果IN子句中的值很多，可以使用LIMIT来限制查询结果的数量，从而提高查询性能。

### 查询优化器的提示

好多，还没看

### count()的查询优化

首先count()在MyISAM并不是一定是最快的，如果有个where条件，那么他跟普通引擎没什么区别。
当然我们可以通过以一种方法达成目的，例如设置where >5,这个如果行数太对，那么可设置为<=5,这样能减少扫描行数了。

### group by 优化

在 MySQL 中，GROUP BY 语句用于将结果集按照一个或多个列进行分组。GROUP BY 语句的执行成本通常很高，因为它需要对结果集进行排序、聚合操作等。因此，我们需要对 GROUP BY 语句进行优化，以提高查询的性能。
以下是一些 MySQL 中 GROUP BY 语句的优化方法：
1、确保使用正确的索引。 GROUP BY 语句的执行需要使用排序操作，如果在 GROUP BY 语句中使用的列没有建立索引，那么 MySQL 就会使用 filesort 进行排序，导致性能下降。因此，我们需要在 GROUP BY 语句中使用索引。
2、尽量减少查询返回的结果集。如果 GROUP BY 语句的结果集非常大，那么排序操作的成本就会很高。因此，我们可以使用 LIMIT 语句来限制结果集的大小，或者使用 WHERE 子句来过滤结果集。
3、尽量避免使用 DISTINCT 关键字。 DISTINCT 关键字会导致 MySQL 对结果集进行排序，因此会降低查询性能。如果我们可以通过 GROUP BY 语句来达到去重的目的，那么就尽量避免使用 DISTINCT 关键字。
4、将 GROUP BY 语句中的列的数量减少到最少。 GROUP BY 语句中列的数量越多，需要排序的成本就越高。因此，我们应该尽量将 GROUP BY 语句中的列数量减少到最少。
5、将 GROUP BY 语句放在子查询中。如果 GROUP BY 语句放在子查询中，那么 MySQL 可以使用索引来完成子查询，然后将结果存储在临时表中，避免了对大表进行排序和聚合操作。
6、使用覆盖索引。如果 GROUP BY 语句中的列已经在索引中包含了所有需要的信息，那么 MySQL 就可以使用覆盖索引来完成查询，避免了对表进行访问

### Limit优化

在 MySQL 中，LIMIT 子句用于限制查询返回的结果集的行数。当查询返回的结果集非常大时，LIMIT 子句可以帮助我们提高查询性能。以下是一些优化 LIMIT 子句的方法：
1、在 LIMIT 子句中指定返回的行数。 LIMIT 子句可以用来控制查询返回的行数，如果我们知道需要返回的行数，那么可以将其直接指定在 LIMIT 子句中，从而避免返回不必要的数据。
2、使用索引来优化 LIMIT 子句。如果查询的结果集需要排序，那么 MySQL 会使用 filesort 算法来进行排序，这会导致性能下降。为了避免这种情况，我们可以建立索引来优化查询。例如，在 ORDER BY 子句中使用了索引，MySQL 就可以使用索引来完成排序操作。
3、将 LIMIT 子句放在子查询中。如果 LIMIT 子句放在子查询中，那么 MySQL 可以使用索引来完成子查询，然后将结果存储在临时表中，避免了对大表进行排序和聚合操作。
4、尽量避免使用 OFFSET 子句。OFFSET 子句用于跳过查询结果集的前几行，然后返回后面的结果。使用 OFFSET 子句会导致 MySQL 必须扫描整个结果集，并跳过前面的行数，这会降低查询性能。因此，我们应该尽量避免使用 OFFSET 子句，尽量使用 WHERE 子句来过滤结果集。
5、将 LIMIT 子句放在查询的末尾。将 LIMIT 子句放在查询的末尾可以帮助 MySQL 更快地返回结果集，因为它不需要等到整个结果集都被扫描完毕才返回结果。

### 大量数据的分页查询

当查询的数据非常大时，使用 LIMIT 子句可能会导致性能问题，因为 MySQL 需要扫描整个结果集并跳过前面的行数，直到达到所需的行数。在这种情况下，可以考虑使用分页来优化查询。
以下是一些优化分页查询的方法：
1、使用缓存来存储结果集。如果查询结果集不会经常变化，那么可以使用缓存来存储结果集，以避免重复查询。缓存可以是内存缓存，也可以是磁盘缓存，这取决于数据的大小和访问模式。
2、使用游标来分批获取数据。如果查询结果集非常大，那么可以使用游标来分批获取数据。游标是一种能够遍历结果集的机制，它可以让我们一次只获取一小部分数据，并避免将整个结果集加载到内存中。
3、使用 Where 条件来分页。如果查询结果集的顺序不重要，那么可以使用 WHERE 子句来分页。例如，如果我们要查询 ID 大于 1000 的前 10 行数据，那么可以使用以下语句：
SELECT * FROM table WHERE id > 1000 LIMIT 10;
这样可以避免 MySQL 扫描整个结果集，从而提高查询性能。
4、使用索引来优化分页。如果查询结果集需要排序，那么可以使用索引来优化查询，以避免 MySQL 使用 filesort 算法进行排序。例如，我们可以在 ORDER BY 子句中使用索引来完成排序操作。
